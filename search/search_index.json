{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the SUPAROO25 documentation","text":"<p>You can access the course overview following this link</p> <p>Access each of the Lecture's tutorials here:</p> <ul> <li>Lecture 1</li> <li>Lecture 2</li> <li>Lecture 3</li> </ul>"},{"location":"#linux-lab-terminal-commands","title":"Linux Lab Terminal Commands:","text":"Command Description <code>ls</code> List files and directories <code>cd</code> Change directory. To go back to the previous directory use <code>cd ..</code> <code>pwd</code> Print working directory <code>touch [filename]</code> Create a new file <code>mkdir [name_of_directory]</code> Create a new directory <code>rm [filename]</code> Remove a file <code>mv [origin] [destination]</code> Move a file <p>Remember to use <code>Tab</code> often to autocomplete commands and paths.</p>"},{"location":"#editing-in-linux","title":"Editing in Linux:","text":"<p>There are several editors available to you in Linux, this might change in a different operating system. Here are some of the most common ones:</p> <ul> <li><code>nano</code></li> <li><code>vim</code></li> <li><code>emacs</code></li> </ul>"},{"location":"#nano","title":"Nano","text":"<p>Nano is a simple text editor that is easy to use. To open a file with nano, type <code>nano [filename]</code>. To save and exit, press <code>Ctrl + X</code>, then <code>Y</code> to confirm, and finally <code>Enter</code> to save. </p>"},{"location":"#vim","title":"Vim","text":"<p>Vim is a more complex text editor that is very powerful. To open a file with vim, type <code>vim [filename]</code>. To edit, press <code>i</code> to enter insert mode (you should see <code>-- INSERT --</code> at the bottom of the terminal). To exit insert mode, press <code>Esc</code>. To save and exit, press <code>Esc</code> to enter command mode, then type <code>:wq</code> and press <code>Enter</code> to save and exit. To exit without saving, press <code>Esc</code> to enter command mode, then type <code>:q!</code> and press <code>Enter</code>. If you have done no changes, you can also press <code>:q</code> and <code>Enter</code> to exit.</p>"},{"location":"#emacs","title":"Emacs","text":"<p>Emacs is another powerful text editor. To open a file with emacs, type <code>emacs [filename]</code>. To save and exit, press <code>Ctrl + X</code>, then <code>Ctrl + S</code> to save, and finally <code>Ctrl + X</code> and <code>Ctrl + C</code> to exit. The advantage of emacs is that it opens in a graphical interface, which can be easier to use.</p>"},{"location":"lecture1/","title":"Lecture 1","text":""},{"location":"lecture1/#reading-and-writing-root-files","title":"Reading and Writing ROOT files","text":"<p>In this first lecture we will learn how to setup ROOT in your machine and the basics of reading and writing ROOT files. </p>"},{"location":"lecture1/#setting-up-root","title":"Setting up ROOT","text":"<p>If you want to install ROOT in your machine, you can follow the instructions in the ROOT website. In my experience one does not simply install ROOT in their first try, so good luck!</p> <p>With access to cvmfs on one of the Lab Room machines, you can simply run the following command in the terminal to setup ROOT (this will have to be done every terminal session):</p> <pre><code>cvmfs_config probe\nsource /cvmfs/sft.cern.ch/lcg/app/releases/ROOT/6.28.12/x86_64-centos8-gcc85-opt/bin/thisroot.sh\nwhich root\nroot\n</code></pre> <p>You can exit ROOT at all times by typing</p> <pre><code>root[1] .q\n</code></pre>"},{"location":"lecture1/#downloading-the-data","title":"Downloading the data","text":"<p>We will use some pregenerated Monte Carlo events coming from ATLAS for the purpose of this tutorial. You can download this data from here, under Lecture1 Input File.</p> <p>This file contains some processed Monte Carlo events for top anti-top pair production for the latest Run3 centre of mass energy of 13.6 TeV at the LHC. </p>"},{"location":"lecture1/#viewing-the-contents-of-the-file","title":"Viewing the contents of the file","text":"<p>We can view the contents of this file by running the following command <code>root [options] [file]</code>. For example:</p> <pre><code>root -l mc23_13p6TeV.ttbar_PP8.root\n</code></pre> <p>Available options are:</p> Option Description -l Start ROOT in interactive mode (no startup screen) -b Start ROOT in batch mode (no graphics) -q Quit ROOT after processing the file -x Exit ROOT after processing the file <p>I would recommend always using the <code>-l</code> option to make it load up faster. In the latest versions of ROOT, specially if you install it on your own machine, there is an annoying new feature were it will always try to open a browser window whenever you draw stuff. You can disable this by opening root like <code>root -l --web=off [more options] [file]</code>.</p> <p>To list the contents of a file you can use the following command:</p> <pre><code>root[1] _file0-&gt;ls()\n</code></pre> <p>By default, if you open the root file as before it will rename it to <code>_file0</code>. Alternatively you can do <code>root[1] .ls</code>, which is faster. You will see a big list of objects in the file, which are the histograms and trees that were saved in the file. Trees are saved as TTree objects and histograms are saved as TH1F, TH1D, TH2F, TH2D, etc. For the latter, the number at the end indicates the number of dimensions of the histogram, and the letter indicates the type of the bin content (F for float, D for double).</p> <p>We are interested in exploring the contents of the TTree called <code>reco</code>, so we can do the following:</p> <pre><code>root[1] reco-&gt;Show(0)\n</code></pre> <p>Note</p> <p>From now on I will omit the <code>root[1]</code> header from the commands. But remember that these commands will only run in the ROOT interpreter.</p> <p>You will again see a big list of TBranches stored in the TTree. With the command <code>reco-&gt;Show(0)</code> we are asking ROOT to show the contents of the first event in the TTree. If you want to see the contents of the 10th event you can do <code>reco-&gt;Show(9)</code>.</p> <p>Other visualisation options</p> <p>There are other ways to explore the contents of the TTree, like <code>reco-&gt;Print()</code> or <code>reco-&gt;Scan()</code>. With the latter you can select which branches you want to see, for example: <pre><code>reco-&gt;Scan(\"jet_pt_NOSYS:jet_eta:jet_phi\")\n</code></pre> With <code>Scan</code> you may also fo simple arithmetic operations like <pre><code>reco-&gt;Scan(\"jet_pt_NOSYS/1000:nElectrons+nMuons\")\n</code></pre></p> <p>You may notice that some branches have a single value associated to them while others, like <code>jet_pt_NOSYS</code>, are labelled as a <code>vector&lt;float&gt;</code>. This is because the TTree is storing a collection of values for that branch. For example, the branch <code>jet_pt_NOSYS</code> is storing the transverse momentum of all jets in each of the events. </p>"},{"location":"lecture1/#tbrowser","title":"TBrowser","text":"<p>Another tool for easy visualisation is the TBrowser. You can open it by running the following command:</p> <pre><code>new TBrowser()\n</code></pre> <p>You will get prompted with an old-school looking window with a list of all the objects in the file. You can click on the objects to see their contents as histograms on the right panel.</p> TBrowser example <p></p> <p>Feel free to explore the contents of the file using the TBrowser. </p> <ul> <li>Can you find the histograms of the variables we were scanning before? </li> <li>Notice how <code>vector&lt;float&gt;</code> branches also show up as normal looking histograms. Can you spot the difference between them and the single value branches?</li> </ul> <p>While this is a nice tool for quick visualisation, it is not very useful for more complex operations. For that we will need to write some code.</p>"},{"location":"lecture1/#writing-some-code-in-the-terminal","title":"Writing some code in the terminal","text":"<p>We can ask root in the command line to draw the same histograms we were seeing in the TBrowser. This will create a new window (or TCanvas as ROOT calls it) with the histogram. The syntax is <code>tree_name-&gt;Draw(\"branch_name\", \"weights*selections\", \"options\")</code>. Available options for drwaing can be found in the THistPainter ROOT Class. Typicalle, using \"HIST E\" will draw a standard histogram with error bars and the data points (it does not care about upper/lower case).</p> <p>For example:</p> <pre><code>reco-&gt;Draw(\"jet_pt_NOSYS/1000\", \"weight_mc_NOSYS\", \"hist\"); // This will draw the jet_pt_NOSYS in GeV and with the Monte Carlo event weight applied\n\nreco-&gt;Draw(\"jet_pt_NOSYS[0]/1000\", \"weight_mc_NOSYS\", \"hist e\"); // This will draw the first jet in the event\n\nreco-&gt;Draw(\"jet_pt_NOSYS/1000\", \"weight_mc_NOSYS*nJets&gt;4\", \"hist e\"); // This will draw the jet_pt_NOSYS histogram only for events with more than 4 jets\n</code></pre> <p>Note</p> <p>The <code>weight_mc_NOSYS</code> branch is a Monte Carlo generator specific weight that is applied to each event to quantify the probability of that event happening for a given process. This is always applied to ensure that the simulation will reproduce the data as closely as possible.  </p> <p>This visualisation method is very powerful for quick checks of your root files as you can reproduce any histogram with any selection you want at the expense of working with the terminal. However, for bigger analysis you will want to write a macro.</p>"},{"location":"lecture1/#advanced-used-of-terminal-commands","title":"Advanced used of terminal commands","text":"<p>As you have seen, the <code>Draw()</code> function outputs a decent-looking histogram, but it is not very flexible. For that you will need to use the TH1 class directly: <code>TH1F(\"hist_name\", \"Title\", Nbins, xmin, xmax)</code> and the <code>Project()</code> function. We can replicate the above diagrams using the following: </p> <pre><code>TH1F *h_jet_pt = new TH1F(\"h_jet_pt\", \"Jet p_{T}\", 25, 0, 400); // I can now control the number and ranges of the bins in the x-axis, as well as giving my plot a title\nreco-&gt;Project(\"h_jet_pt\", \"jet_pt_NOSYS/1000\", \"weight_mc_NOSYS\"); // This is the equivalent of the Draw() function\nh_jet_pt-&gt;Draw(\"hist\"); // This will draw the histogram in a new canvas\n</code></pre> <p>At this stage one can also make the plot more fancy by adding a legend, axis labels, changing the line color and style, aspect ratio, etc. But we will dive into all of these options in the next lecture.</p>"},{"location":"lecture1/#looping-over-the-root-file","title":"Looping over the ROOT file","text":"<p>For more complex calculations, for instance if you want to calculate the invariant mass of a pair of jets, or boost to a certain frame, you will need to write a macro. You may use either Pyhton or C++ for this, whatever you feel more comfortable with. You can run the Python code in the terminal using <code>python3.11 [programName.py]</code> and the C++ code using <code>root -l [programName.C]</code>.</p> <p>Below are two example codes that do the exact same thing, but one is in Python and the other in C++. Both loop over all of the events and declare two histograms, one for the leading jet transverse momentum and another for the number of jets in the event. </p> <p>Note that none of them will produce any output since they are just internally declaring the histograms, however if you run the C++ version you will have access to the newly created histograms in the ROOT interpreter. This means you can plot them using e.g. <code>h_lead_jet_pt-&gt;Draw()</code>.</p> <pre><code>#include &lt;TFile.h&gt;\n#include &lt;TTree.h&gt;\n\nvoid programName() {\n\n    // Declare a new file with the option \"READ\"\n    TFile *f = new TFile(\"mc23_13p6TeV.ttbar_PP8.root\", \"READ\");\n    // Fetch the TTree called \"reco\" from the file\n    TTree *reco = (TTree*)f-&gt;Get(\"reco\");\n\n    // Declare the variables that will be stored in the branches\n    Int_t nJets;\n    std::vector&lt;float&gt; *jet_pt = nullptr;\n\n    // Link the branches to the variables SetBranchAddress(\"branch_name_in_tree\", &amp;variable)\n    reco-&gt;SetBranchAddress(\"jet_pt_NOSYS\", &amp;jet_pt);\n    reco-&gt;SetBranchAddress(\"nJets\", &amp;nJets);\n\n    // Declare the histograms\n    TH1F *h_lead_jet_pt = new TH1F(\"h_lead_jet_pt\", \"Leading jet p_{T}\", 25, 0, 400);\n    TH1F *h_nJets = new TH1F(\"h_nJets\", \"Number of jets\", 10, 0, 10);\n\n    // Loop over all the events in the TTree and fill the histograms\n    for (Int_t i = 0; i &lt; reco-&gt;GetEntries(); i++) {\n        reco-&gt;GetEntry(i);\n        h_lead_jet_pt-&gt;Fill(jet_pt-&gt;at(0)/1000);\n        h_nJets-&gt;Fill(nJets);\n    }\n}\n</code></pre> <p>Python version of the code</p> <pre><code>import ROOT\n\n# Declare a new file with the option \"READ\"\nf = ROOT.TFile(\"mc23_13p6TeV.ttbar_PP8.root\")\n# Fetch the TTree called \"reco\" from the file\nreco = f.Get(\"reco\")\n\n# Declare the histograms\nh_lead_jet_pt = ROOT.TH1F(\"h_lead_jet_pt\", \"Leading jet p_{T}\", 25, 0, 400)\nh_nJets = ROOT.TH1F(\"h_nJets\", \"Number of jets\", 10, 0, 10)\n\n# Loop over all the events in the TTree and fill the histograms\nfor i in range(reco.GetEntries()):\n    reco.GetEntry(i)\n    h_lead_jet_pt.Fill(reco.jet_pt_NOSYS[0]/1000)\n    h_nJets.Fill(reco.nJets)\n</code></pre> <ul> <li>Both codes have the same bug that will throw an error. Can you spot it, and fix it? </li> <li>In addition, these examples fill the histograms while ignoring the event weight. Can you add the MC event weight to the histograms?</li> </ul>"},{"location":"lecture1/#rdataframe","title":"RDataFrame","text":"<p>The RDataFrame class is a new feature in ROOT that allows you to do complex operations on the TTree in a more Pythonic way. The full documentation along with more examples can be found in the RDataFrame Class. For example, the following code will do the same as the previous examples, but in a more compact way:</p> <pre><code>void programName() {\n    // We select the TTree and the file at the same time\n    ROOT::RDataFrame d(\"reco\", \"mc23_13p6TeV.ttbar_PP8.root\"); \n\n    // Automatic booking of the histogram, TBranch and variable type\n    auto h_nJets = d.Histo1D&lt;int&gt;(\"nJets\");\n\n    // This runs the event loop, it's equivalent to the for loop we implemented above\n    h_nJets-&gt;DrawClone();\n}\n</code></pre> Possible crashes with ROOT <p>You may notice that when you run the code for the first time it runs smoothly, but upon running it again inside the ROOT interpreter, with <code>.x programName.C</code> you will get a crash. While I don't know the exact reason why this happens, I suspect it is because ROOT is trying to create the histograms again, but they already exist within the running session. You can fix this by existing ROOT and running the <code>root programName.C</code> again. </p> <p>Python version of the code</p> <pre><code>import ROOT\n\n# We select the TTree and the file at the same time\nd = ROOT.RDataFrame(\"reco\", \"mc23_13p6TeV.ttbar_PP8.root\")\n\n# Automatic booking of the histogram and TBranch and variable type\nh_nJets = d.Histo1D(\"nJets\")\n\n# This runs the event loop, it's equivalent to the for loop we implemented above\nh_nJets.DrawClone()\n</code></pre>"},{"location":"lecture1/#writing-to-a-root-file","title":"Writing to a ROOT file","text":"<p>Now that we have explored the contents of the file, we can write some new histograms, trees and branches to a new root file. This is very useful if you want to save the results of your analysis for later use. We will make use of the <code>TObject::Write</code> method and <code>TFile(\"[filename]\", \"[option]\")</code> class with the following options:</p> Option Description READ Open the file for reading RECREATE Create a new file, if it already exists it will be overwritten UPDATE Open the file for reading and writing CREATE Create a new file, if it already exists it will throw an error <pre><code>#include &lt;TFile.h&gt;\n#include &lt;TTree.h&gt;\n\nvoid programName() {\n\n    // Declare a new file with the option \"RECREATE\"\n    TFile *f = new TFile(\"out.root\", \"RECREATE\");\n    // Declare a new tree with the name \"tree\" and the title \"Example Tree\"\n    TTree *tree = new TTree(\"tree\", \"Example Tree\");\n\n    // Declare a float variable \"poisson\"\n    float poisson;\n    // Declare a histogram with the name \"h\", the title \"Poisson\", 10 bins from 0 to 10\n    TH1F *h = new TH1F(\"h\", \"Poisson\", 10, 0, 10);\n\n    // Book the branch \"branch_poisson\" to the tree and link it to the variable \"poisson\", you can also specify the variable type\n    tree-&gt;Branch(\"branch_poisson\", &amp;poisson, \"poisson/F\");\n\n    for (Int_t i = 0; i &lt; 1000; i++) {\n        // For each 'event', fill the variable 'poisson' with a Poisson distribution with mean 5\n        poisson = gRandom-&gt;Poisson(5);\n        // Fill the histogram with the value of 'poisson'\n        h-&gt;Fill(poisson);\n        // Fill al the branches of the tree\n        tree-&gt;Fill();\n    }\n\n    // Write the histogram and the tree to the file\n    h-&gt;Write();\n    tree-&gt;Write();\n\n    // Close the file\n    f-&gt;Close();\n\n}\n</code></pre> <p>Python version of the code</p> <pre><code>import ROOT\nfrom array import array\n\n# Declare a new file with the option \"RECREATE\"\nf = ROOT.TFile(\"out.root\", \"RECREATE\")\n# Declare a new tree with the name \"tree\" and the title \"Example Tree\"\ntree = ROOT.TTree(\"tree\", \"Example Tree\")\n\n# Declare a 1D float array to store the variable \"poisson\"\npoisson = array('f', [0])\n# Declare a histogram with the name \"h\", the title \"Poisson\", 10 bins from 0 to 10\nh = ROOT.TH1F(\"h\", \"Poisson\", 10, 0, 10)\n\n# Book the branch \"branch_poisson\" to the tree and link it to the variable \"poisson\", you can also specify the variable type\ntree.Branch(\"branch_poisson\", poisson, \"poisson/F\")\n\nfor i in range(1000):\n    # For each 'event', fill the variable 'poisson' with a Poisson distribution with mean 5\n    poisson[0] = ROOT.gRandom.Poisson(5)\n    # Fill the histogram with the value of 'poisson'\n    h.Fill(poisson[0])\n    # Fill all the branches of the tree\n    tree.Fill()\n\n# Write the histogram and the tree to the file\nh.Write()\ntree.Write()\n\n# Close the file\nf.Close()\n</code></pre> Overwriting TObjects <p>Sometimes ROOT does not want to cooperate when rewriting existing trees or histagrams, you can force this to happen by calling the <code>TObject::Write</code> method with the option <code>kOverwrite</code>. For example: <pre><code>tree-&gt;Write(\"\", TObject::kOverwrite);\n</code></pre></p> <p>You can now inspect the new root file with the methods we have learned before. </p> <ul> <li>Notice how branches will always be saved inside the TTree, while the histogram is stored as a separate object in the file. </li> <li>Check out how the same data is represented in the TH1F histogram and the TBranch. Which method do you prefer? Which one is more flexible?</li> <li>We have seen how vectors are very commonly used as well. Can you modify the code to save a <code>vector&lt;float&gt;</code> branch that contains a Poisson distribution with mean=1 in the first element, mean=2 in the second, and so on?</li> </ul> Vector Solution SPOILER! <pre><code>std::vector&lt;float&gt; poisson_vector;\ntree-&gt;Branch(\"branch_poisson_vector\", &amp;poisson_vector);\nfor (Int_t i = 0; i &lt; 1000; i++) {\n    // For each 'event', we first clear the vector\n    poisson_vector.clear();\n    for (Int_t j = 0; j &lt; 10; j++) {\n        // We use the push_back method to each of the elements to the vector\n        poisson_vector.push_back(gRandom-&gt;Poisson(j+1));\n    }\n    tree-&gt;Fill();\n}\n</code></pre> <p>This concludes the first lecture. In the next one we will learn how to make more complex plots, how to fit functions to histograms, and how to make your plots look more professional. Below is an exercise that will put to test all the knowledge you have acquired in this lecture.</p>"},{"location":"lecture1/#exercise-1","title":"Exercise 1","text":"<ol> <li>Write a macro that reads the file <code>mc23_13p6TeV.ttbar_PP8.root</code> and saves at least the following branches to a new root file called <code>ttbar_PP8_analysis.root</code>:<ul> <li>The jet transverse momentum (<code>vector&lt;float&gt; jet_pt_NOSYS</code>)</li> <li>The lepton transverse momentum (<code>vector&lt;float&gt; lepton_pt_NOSYS</code>)</li> <li>The lepton pseudorapidity (<code>vector&lt;float&gt; lepton_eta</code>)</li> <li>The lepton azimuthal angle (<code>vector&lt;float&gt; lepton_phi</code>)</li> <li>The lepton energy (<code>vector&lt;float&gt; lepton_e_NOSYS</code>)    </li> <li>The number of jets in the event (<code>int nJets</code>)</li> <li>The number of leptons in the event (<code>int nLeptons</code>)</li> <li>The number of b-jets in the event (<code>int nBjets_GN2v01_77WP</code>)</li> <li>The event Monte Carlo weight (<code>float weight_mc_NOSYS</code>)</li> </ul> Advanced Hint <p>Look up the <code>TTree::CloneTree()</code> and <code>TTree::SetBranchStatus()</code> methods in the ROOT documentation to make your code smarter and faster.</p> </li> <li>From the new root file: <ul> <li>What are the average values for the number of jets, b-jets and leptons in the sample? This is a ttbar NLO sample, where both tops decay leptonically (e.g. t-&gt;Wb-&gt;l\u03bdb), do the values you see make sense?</li> <li>Make a histogram of the leading and sub-leading jet transverse momentum for events with at least 3 jets and at least 1 b-jet. Remember that events in a histogram should be weighted using the Monte Carlo weight. Save it to the same root file.</li> <li>Make another histogram of the leading lepton transverse momentum for events with at least 2 leptons, at least 1 b-jet and save it.</li> </ul> <p>Physics content</p> <p>In these root files, the first element of the <code>jet_pt</code> (or any <code>jet*</code>, <code>lepton*</code> branch) <code>vector&lt;float&gt;</code> corresponds to the leading jet, i.e. the jet with the highest transverse momentum in the whole event. They have already been ordered for you to make it easier.</p> </li> <li>Construct the lepton's four-momentum vectors and calculate the invariant mass of the lepton pair (the leading and subleading leptons in the event). Make a histogram of the invariant mass for events with exactly 2 leptons and at least 1 b-jet. Save it to the same root file.</li> </ol> Hint <p>Look up the <code>TLorentzVector</code> class in the ROOT documentation.     </p>"},{"location":"lecture2/","title":"Lecture 2","text":""},{"location":"lecture2/#plotting-in-root","title":"Plotting in ROOT","text":"<p>In the previous lecture we have seen how to create a histogram in ROOT. Now we will see how you can modify it a plot it in different ways. Any time you called the <code>Draw()</code> method a new window popped up with the histogram. Internally ROOT was creating a TCanvas to draw the histogram. It is more convenient to define the canvas yourself as it allows for more flexibility and the ability to save your histograms as files. Inside a canvas you can have multiple pads, which are the areas where you can draw your histograms, graphs, etc. Below is an example of how to create a canvas with a single (default) pad and draw a histogram in it.</p> <pre><code>{\n    TH1::SetDefaultSumw2(); // Setting the sum of squares of weights to be stored in the histogram\n\n    // Declaring the TCanvas(\"[canvas identifier]\", \"[name of canvas]\",  width, height)\n    TCanvas *c1 = new TCanvas(\"c1\",\"c1\",800,600); \n    TH1D *hist = new TH1D(\"hist\",\"hist\",20,-3,3);\n\n    // Filling and Drawing the histogram with a random gaussian distribution centered at 0 with a sigma of 1\n    hist-&gt;FillRandom(\"gaus\",1000);\n\n    // Selecting the canvas, this is not necessary if you have only one pad/canvas but it is good practice\n    c1-&gt;cd(); \n\n    // Drawing the histogram\n    hist-&gt;Draw(); \n\n    // Updating the canvas, this is not necessary but can solve problems sometimes\n    c1-&gt;Update(); \n\n    // Saving the canvas as a .png file \n    c1-&gt;SaveAs(\"histogram.png\"); \n}\n</code></pre>"},{"location":"lecture2/#decorating-the-plot","title":"Decorating the Plot","text":"<p>We can further decorate the plot, we can add a TLegend class, change the axis labels, the title, the line color, the fill color, etc (more stuff in THistPainter class). Below is an example of how to do this.</p> <pre><code>{\n    // [previous code]\n\n    // Drawing the histogram\n    hist-&gt;Draw(\"hist e1\"); \n\n    // Adding a legend, declaring the (x,y) position in the canvas TLegend(x1,y1,x2,y2)\n    TLegend *legend = new TLegend(0.1,0.7,0.48,0.9);\n\n    // Entries can be added with the AddEntry([hisotgram identifier], \"[name]\", \"[line type]\") method, linking it to histogram\n    legend-&gt;AddEntry(hist,\"Gaussian Distribution\",\"l\");\n\n    // Make a transparent and borderless legend, looks better\n    legend-&gt;SetFillStyle(0);\n    legend-&gt;SetBorderSize(0);\n    legend-&gt;Draw();\n\n    // Changing the axis labels\n    hist-&gt;GetXaxis()-&gt;SetTitle(\"Values\");\n    hist-&gt;GetYaxis()-&gt;SetTitle(\"Frequency\");\n\n    // Changing the title\n    hist-&gt;SetTitle(\"Gaussian Distribution\");\n\n    // Changing the line color\n    hist-&gt;SetLineColor(kRed);\n\n    // Changing the fill color, the second argument is the transparency\n    hist-&gt;SetFillColorAlpha(kOrange, 0.5);\n\n    // Updating the canvas, this is not necessary but can solve problems sometimes\n    c1-&gt;Update(); \n\n    // Saving the canvas as a .png file \n    c1-&gt;SaveAs(\"histogram.png\");  \n}\n</code></pre>"},{"location":"lecture2/#setting-the-style","title":"Setting the Style","text":"<p>By default ROOT creates a default style that can be accessed via the member of the TStyle class, the gStyle pointer, which has access to the currently active style. This class includes functions to set canvases, pads, lines, markers, axes, etc. You can play around with the built-in ones by setting at the stat of your script:</p> <pre><code>// Available values: Classic, Plain, Bold, Video, Pub, Modern (default), ATLAS, BELLE2\ngROOT-&gt;SetStyle(\"[style name]\");\n</code></pre> <p>You may also create your onw style and then load it up in your macros. If you come up with something you really like you can save this style as a separate macro and call it from any other macro you create to keep consistency. Here is an example of how you would do this:</p> <pre><code>{\n    // Creating a new style\n    TStyle *myStyle = new TStyle(\"myStyle\",\"My Style\");\n\n    myStyle-&gt;SetCanvasColor(0); \n    myStyle-&gt;SetPadColor(0); \n    myStyle-&gt;SetLineWidth(2);\n    myStyle-&gt;SetPadTopMargin(0.8);\n\n    // [and many more options]\n\n    gROOT-&gt;SetStyle(\"myStyle\");\n}\n</code></pre>"},{"location":"lecture2/#ratio-panels","title":"Ratio Panels","text":"<p>When comparing two histograms, adding a ratio plot is sometimes essential to spot problems. If you are comparing real data to simulated one (which is usually always the case in particle physics) they are very useful to spot modelling issues. Below is an example of how to do this:</p> <pre><code>{\n    TH1::SetDefaultSumw2(); // Setting the sum of squares of weights to be stored in the histogram\n\n    gStyle-&gt;SetOptStat(0); // Setting the statistics box to be off by default\n    gStyle-&gt;SetOptTitle(0); // Setting the title box to be off by default\n\n    // Declaring the TCanvas(\"[canvas identifier]\", \"[name of canvas]\",  width, height)\n    TCanvas *c1 = new TCanvas(\"c1\",\"c1\",800,600);\n\n    // Declare both pads with TPad(\"[pad identifier]\", \"[name of pad]\", x1, y1, x2, y2)\n    TPad *up = new TPad(\"up\", \"up\", 0, 0.3, 1, 1); \n    TPad *low = new TPad(\"low\", \"low\", 0, 0, 1, 0.3);\n\n    // Declare the histograms\n    TH1D *h_model = new TH1D(\"h_model\", \"Theory Model\", 50, -3, 3); \n    TH1D *h_data = new TH1D(\"h_data\", \"Observed Data\", 50, -3, 3); \n\n    // Random number generator\n    TRandom3 *rand = new TRandom3(); \n\n    // Fill the histograms with slightly different Gaussian distributions\n    for (int i = 0; i &lt; 1000000; i++) {\n        h_data-&gt;Fill(rand-&gt;Gaus(0, 1));\n        h_model-&gt;Fill(0.85*rand-&gt;Gaus(0.02, 1.2));\n    }\n\n    // Draw both pads\n    c1-&gt;cd();\n    up-&gt;Draw();\n    low-&gt;Draw();\n\n    // Move the the upper pad and change the bottom margin\n    up-&gt;cd();\n    up-&gt;SetBottomMargin(0.05);\n\n    // Draw the histograms and modify the style\n    h_data-&gt;Draw(\"hist p e x0\");\n    h_data-&gt;SetMarkerStyle(20);\n    h_data-&gt;SetMarkerSize(0.7);\n    h_data-&gt;SetMarkerColor(kBlack);\n    h_data-&gt;SetLineColor(kBlack);\n    h_data-&gt;GetYaxis()-&gt;SetTitle(\"Entries\");\n    h_data-&gt;GetYaxis()-&gt;SetTitleSize(0.045);\n    h_data-&gt;GetYaxis()-&gt;SetTitleOffset(1);\n    h_data-&gt;GetYaxis()-&gt;SetLabelSize(0.04);\n    h_data-&gt;GetXaxis()-&gt;SetLabelSize(0);\n\n    h_model-&gt;Draw(\"hist same e\");\n    h_model-&gt;SetLineColor(kBlue);\n\n    // Add a legend\n    TLegend *leg = new TLegend(0.7, 0.7, 0.9, 0.9);\n    leg-&gt;AddEntry(h_data, \"Data\", \"p e\");\n    leg-&gt;AddEntry(h_model, \"Model\", \"l\");\n    leg-&gt;Draw();\n    leg-&gt;SetBorderSize(0);\n    leg-&gt;SetFillStyle(0);\n\n    // Move to the lower pad, set the grid and margins\n    low-&gt;cd();\n    low-&gt;SetGridy();\n    low-&gt;SetBottomMargin(0.3);\n\n    // Create a ratio histogram, this is done by dividing the data by the model\n    TH1D *h_ratio = (TH1D*)h_data-&gt;Clone(\"h_ratio\");\n    h_ratio-&gt;Divide(h_model);\n\n    // Draw the histograms and customise the style\n    h_ratio-&gt;Draw(\"hist p e x0\");\n    h_ratio-&gt;SetMarkerStyle(20);\n    h_ratio-&gt;SetMarkerSize(0.7);\n    h_ratio-&gt;GetYaxis()-&gt;SetNdivisions(505);\n    h_ratio-&gt;GetYaxis()-&gt;SetLabelSize(0.1);\n    h_ratio-&gt;GetYaxis()-&gt;SetTitle(\"Data / Model\");\n    h_ratio-&gt;GetYaxis()-&gt;SetTitleOffset(0.4);\n    h_ratio-&gt;GetYaxis()-&gt;SetTitleSize(0.1);\n\n    h_ratio-&gt;GetXaxis()-&gt;SetLabelSize(0.1);\n    h_ratio-&gt;GetXaxis()-&gt;SetTitle(\"Values\");\n    h_ratio-&gt;GetXaxis()-&gt;SetTitleOffset(1.2);\n    h_ratio-&gt;GetXaxis()-&gt;SetTitleSize(0.1);\n\n    // Divide the model histogram by itself to create a line at 1 with correct errors\n    TH1D *h_ratio_one = (TH1D*)h_model-&gt;Clone(\"h_ratio_one\");\n    h_ratio_one-&gt;Divide(h_model);\n    h_ratio_one-&gt;Draw(\"hist same e\");\n\n    // Update the canvas and save the plot\n    c1-&gt;Update();\n    c1-&gt;SaveAs(\"ratio.png\");\n}\n</code></pre> <p></p> <p>As you can appreciate most of the code deals with setting the correct label and axis title sizes/offset to make the plot readable, this is a very annoying part of ROOT. You can access the 'default' values of your plot by calling one of the <code>Get()</code> methods, i.e. <code>histogram-&gt;GetYaxis()-&gt;GetTitleSize()</code>, and then modify it accordingly. But most of the time it's a bit of guess work.</p> <p>You can also use the TRatioPlot class which can avoid all this hassle and automatically create the ratio plot for you. The default output from this class is a bit ugly and it seems to take over any style you have selected in you main pad, but it is much faster and easier to use for quick comparisons.</p> <pre><code>{\n    // [previous code]\n\n    // Create the ratio plot\n    TRatioPlot *rp = new TRatioPlot(h_data, h_model);\n    rp-&gt;Draw();\n\n    // Update the canvas and save the plot\n    c1-&gt;Update();\n    c1-&gt;SaveAs(\"ratio.png\");\n}\n</code></pre>"},{"location":"lecture2/#other-types-of-plots","title":"Other types of plots","text":""},{"location":"lecture2/#tprofile","title":"TProfile","text":"<p>A profile histogram is a histogram that contains the mean value of the Y variable for each bin in X. It is useful when you have a large number of points in a bin and you want to see the mean value of the Y variable. This video explains it very well with a simple example: TProfile tutorial. TProfile has also access to all TH1 options for plotting and setting the style.</p>"},{"location":"lecture2/#tgraph-and-tgrapherrors","title":"TGraph and TGraphErrors","text":"<p>These types of plots are your standard line graphs with uncertainties. They are very useful when you can't draw your functions properly with TH1 or you have a set of points you want to plot. You can read more about the in the TGraph class, TGraphErrors class and also TGraphAsymmErrors class for asymmetric errors.</p> <p>In particle physics they are not as common and typically histograms are treated as if they were graphs, but they can be the better choice in other cases. To achieve this, one can use the <code>TH1::SetBinConent()</code> method to set the y values and the <code>TH1::SetBinError()</code> method to set the uncertainties. </p> <p>Below is an example of how you can plot a TGraph of a Gaussian function with a background slope:</p> <pre><code>{\n    // Declaring the TCanvas(\"[canvas identifier]\", \"[name of canvas]\",  width, height)\n    TCanvas *c1 = new TCanvas(\"c1\",\"c1\",800,600);\n\n    TF1 *func = new TF1(\"func\", \"gaus + [3]*x\", 0, 10); // Declaring the function to be plotted\n\n    // Set the parameters of the Gaussian(3)\n    func-&gt;SetParameter(0, 1); // Amplitude\n    func-&gt;SetParameter(1, 5); // Mean\n    func-&gt;SetParameter(2, 1); // Standard deviation\n\n    // Set the parameters of the linear function\n    func-&gt;SetParameter(3, 0.1); // Slope\n\n    // Declaring the graph to be plotted\n    TGraph *graph = new TGraph(); \n\n    // Filling the graph with the function values\n    for (int i = 0; i &lt; 50; i++) {\n        graph-&gt;SetPoint(i, i/5., func-&gt;Eval(i/5.));\n    }\n\n    // Drawing the graph\n    graph-&gt;Draw(\"AP\"); \n    graph-&gt;SetMarkerStyle(20);\n}\n</code></pre> <p>A couple of notes on this code:</p> <ul> <li><code>TGraph()</code> has many constructors, you can define it with a set number of points <code>TGraph(int n)</code>, with a set of x and y values <code>TGraph(int n, vector x, vector y)</code>, or even empty as shown here and then fill it up later. The latter allows for more flexibility if your dataset size is unknown.</li> <li>The above code can also be done by just plotting the function directly with <code>func-&gt;Draw()</code>, but this is a simple example to show how to use TGraph.</li> <li>Perhaps a more common use of TGraph is to read arrays of numbers for x and y values, along with their uncertainties and plot them; there are plenty of examples online on how to do this.</li> </ul>"},{"location":"lecture2/#fitting-in-root","title":"Fitting in ROOT","text":"<p>Fitting custom functions in ROOT is done with a combination of the TF1 class and the TH1::Fit() method. The following code will attempt to fit and extract the Gaussian parameters of an analogous function to the one we defined in the <code>TGraph</code> example.</p> This CODE is quite long <pre><code>#include &lt;TH1.h&gt;\n#include &lt;TF1.h&gt;\n#include &lt;TCanvas.h&gt;\n\n// We can define two separate functions to account for the background and the signal Gaussian peak\nDouble_t background(Double_t *x, Double_t *par) {\n    return par[0] + par[1]*x[0];\n}\n\nDouble_t gaussian(Double_t *x, Double_t *par) {\n    return par[0]*TMath::Gaus(x[0], par[1], par[2]);\n}\n\n// Then we can add them together to get the full function\nDouble_t fitFunction(Double_t *x, Double_t *par) {\n    return background(x, par) + gaussian(x, &amp;par[2]);\n}\n\nvoid gaussian_fit() \n{\n    gStyle-&gt;SetOptStat(0); // Setting the statistics box to be off by default\n\n    // Declaring the TCanvas(\"[canvas identifier]\", \"[name of canvas]\",  width, height)\n    TCanvas *c1 = new TCanvas(\"c1\",\"c1\",800,600);\n\n    // We will first generate some plausible looking data to fit according to the function we defined\n    TF1 *func_data = new TF1(\"func\", fitFunction, 0, 10, 5); \n\n    func_data-&gt;SetParameter(0, 10); // Intercept\n    func_data-&gt;SetParameter(1, 4); // Slope\n    func_data-&gt;SetParameter(2, 25); // Amplitude\n    func_data-&gt;SetParameter(3, 3); // Mean\n    func_data-&gt;SetParameter(4, 0.6); // Standard deviation\n\n    TRandom3 *rand = new TRandom3();\n\n    TH1D *hist = new TH1D(\"hist\", \"hist\", 40, 0, 10);\n\n    for (int i = 0; i &lt; 40; i++) {\n        double center = hist-&gt;GetBinCenter(i+1);\n        // To add a bit of randomness we will add some aritficical noise to the data\n        double content = func_data-&gt;Eval(center) + rand-&gt;Gaus(0, 3);\n        hist-&gt;SetBinContent(i+1, content);\n        hist-&gt;SetBinError(i+1, TMath::Sqrt(content));\n    }\n\n    // Drawing the graph\n    hist-&gt;Draw(\"hist p e x0\"); \n    hist-&gt;SetLineColor(kBlack);\n    hist-&gt;SetMarkerStyle(20);\n    hist-&gt;SetMinimum(0);\n\n    // Setting \"Title;X axis label;Y axis label\"\n    hist-&gt;SetTitle(\"Gaussian Peak on Linear Background;X;Entries\");\n\n    // To make it completely decoupled, we create another function to fit the data\n    TF1 *func = new TF1(\"func\", fitFunction, 0, 10, 5);\n\n    // We set an initial guess for the parameters\n    func-&gt;SetParameters(1, 1, 1, 1, 1);\n\n    // Fit parameters to the data will be stored in the array par\n    Double_t par[5];\n    hist-&gt;Fit(\"func\");\n\n    func-&gt;Draw(\"same\");\n    func-&gt;GetParameters(par);\n    func-&gt;SetLineColor(kRed);\n    func-&gt;SetLineStyle(2);\n    func-&gt;SetNpx(500);\n\n    // While the funciton fits both signal and background together, we can decouple those to make the visualisation of the fit better\n    TF1 *bckg = new TF1(\"bckg\", background, 0, 10, 2);\n\n    // We input the fit parameters to the background function and just plot it\n    bckg-&gt;SetParameters(par);\n    bckg-&gt;Draw(\"same\");\n    bckg-&gt;SetLineColor(kGreen);\n    bckg-&gt;SetNpx(500);\n\n    // Same for the Gaussian peak\n    TF1 *gaus = new TF1(\"gaus\", \"gaussian\", 0, 10, 3);\n    gaus-&gt;SetParameters(&amp;par[2]);\n    gaus-&gt;Draw(\"same\");\n    gaus-&gt;SetLineColor(kBlue);\n    gaus-&gt;SetNpx(500);\n\n    // We finalise the plot by addding a legend\n    TLegend *leg = new TLegend(0.6, 0.2, 0.9, 0.4);\n    leg-&gt;SetFillStyle(0);\n    leg-&gt;SetBorderSize(0);\n    leg-&gt;AddEntry(hist, \"Data\", \"ep\");\n    leg-&gt;AddEntry(func, \"Global Fit\", \"l\");\n    leg-&gt;AddEntry(bckg, \"Background Fit\", \"l\");\n    leg-&gt;AddEntry(gaus, \"Gaussian Fit\", \"l\");\n    leg-&gt;Draw();\n\n    // Some prints of the Gaussian peak parameters\n    cout &lt;&lt; \"Amplitude: \" &lt;&lt; par[2] &lt;&lt; endl;\n    cout &lt;&lt; \"Mean: \" &lt;&lt; par[3] &lt;&lt; endl;\n    cout &lt;&lt; \"Sigma: \" &lt;&lt; par[4] &lt;&lt; endl;\n\n    c1-&gt;Update();\n    c1-&gt;SaveAs(\"Gaussian_fit.png\");\n}\n</code></pre> <p></p> <p>You can see how the final fit results agree quite well with the initial parameters we used to generate the data. The background and the Gaussian peak are also well separated and can be visualised separately. This is a very common practice in particle physics where you have a signal peak on top of a background distribution.</p>"},{"location":"lecture2/#exercise-2","title":"Exercise 2","text":"<p>The necessary files for the exercise are here: Exercise 2, courtesy of last years lecturer: Dr. Dwayne Spiteri. They are also posted in the course website.</p> <p>We\u2019re going to perform a search for the Higgs via it\u2019s subsequent decay into a pair of photons \\((H \\rightarrow \\gamma\\gamma)\\). It has a tiny branching ratio but a distinctive signature due to the two photons having good energy resolution.</p> <p><code>PsuedoData_Histogram_100fb.root</code> is the data that was measured corresponding to 100fb\\(^{\u22121}\\). </p> <p><code>Signal_1fb.root</code> and <code>Background_1fb.root</code> are the signal and background simulations corresponding to 1fb\\(^{\u22121}\\). The <code>TTrees</code> in the simulation files contain two variables: diphoton invariant mass (invariant-Mass) and the event weight (eventWeight).</p> <p>Your task is to:</p> <ol> <li>Plot the data:<ol> <li>Plot the TH1D histogram called <code>signal</code> in the (Psuedo-)data file (1st canvas)</li> </ol> </li> <li>Plot the background simulation<ol> <li>Create histogram of invariant-Mass weighted by the eventWeight (2nd canvas).</li> <li>Scale simulation to match luminosity of the data. Hint: The number of events in particle physics is proportional to the the luminosity. So a 100fb\\(^{\u22121}\\) sample will have 10x more events than a 10fb\\(^{\u22121}\\) one.</li> <li>Perform a fit on the background model, there are many default functions in ROOT that you can try. Which one do you think is the best? Which metric can you use to determine this?</li> </ol> </li> <li>Background-only hypothesis test<ol> <li>Plot the data and background on the same plot (3rd canvas).</li> <li>Plot the difference between data and background in a subplot/ratio plot.</li> </ol> </li> <li>Finalise the plot<ol> <li>Add the signal to that of the background (can be done in the same canvas as the previous step).</li> <li>Make the plot look pretty like you want to put it on a mug or your fridge.</li> </ol> </li> <li>Extract the Higgs mass - Advanced<ol> <li>You will see a significant excess of data over your background which should be well modelled by the signal+background expectation. Now, find the best way to extract the observed Higgs mass from the DATA distribution.</li> <li>How good is this fit? How can you improve it? Which function works better?</li> <li>From the fit results extract the mass of the Higgs boson and the uncertainty on this measurement. How does it compare to the measured value of \\(m_H=125~\\text{GeV}\\)?</li> </ol> </li> </ol>"},{"location":"lecture3/","title":"Lecture 3","text":"<p>This lecture is mostly aimed at adding a few more tools to manage and manipulate data in ROOT. At the end of the lecture there you will find the description of the projects that you can work on.</p>"},{"location":"lecture3/#tree-friending","title":"Tree Friending","text":"<p>If you want to access information from one tree while within another, you can link the trees in a process called \u201cfriending\u201d. A common example is to link together reconstructed event (reco) trees with their respective truth trees. But here it is important that the trees have the same events, otherwise the linking will produce wrong results.</p> <p>Oftentimes root files have multiple trees in them, if you have loaded a root file like this then, the syntax for friending TTrees is simple:</p> <pre><code>[basetree]-&gt;AddFriend([friendtree])\n</code></pre> <p>But you can also add friends from other files.</p> <pre><code>[basetree]-&gt;AddFriend([friendtree],[filename])\n</code></pre> <p>With this, both trees may be accessed when scanning or drawing branches from the command line, like:</p> <pre><code>[basetree]-&gt;Scan([basetree].[branchname1]:[friendtree].[branchname1])\n</code></pre> <p>By default the friends will be added on some internal index. But again, this might be useless if you are not dealing with the same events from both trees. It is possible to specify how the trees are linked by using the <code>BuildIndex</code> function. This function is used to specify the branch that will be used to link the two trees:</p> <pre><code>[basetree]-&gt;BuildIndex([branchname]);\n[friendtree]-&gt;BuildIndex([branchname]);\n[basetree]-&gt;AddFriend([friendtree]);\n</code></pre> <p>Particle Physics example</p> <pre><code>// Some preceding code\n\n// In particle physics, truth trees usually contain information of the event before the detector simulation, so they typically have more events than the reco tree since many cuts are applied at reco level. If we wanted to loop over the truth tree, bt only for events ont the reco tree, we could do the following:\n\ntruthTree-&gt;BuildIndex(\"runNumber\", \"eventNumber\");\n\nfor (int i = 0; i &lt; recoTree-&gt;GetEntries(); i++) {\n    recoTree-&gt;GetEntry(i);\n    truthTree-&gt;GetEntryWithIndex(recoTree-&gt;runNumber, recoTree-&gt;eventNumber);\n\n    // Do something with the truth tree\n    // [...]\n}\n</code></pre>"},{"location":"lecture3/#merging-trees","title":"Merging Trees","text":"<p>There are multiple ways to mix root files together, assuming that they have the same internal structure. Otherwise it might be a nightmare to do it. The simplest is to us the <code>hadd</code> command in the terminal. This command is used to merge ROOT files together, and it can be used to merge trees as well. The syntax in the following:</p> <pre><code>hadd [outputfile] [inputfile1] [inputfile2] ...\n</code></pre> <p>Another useful way to merge files is to use the <code>TChain</code> class. This is a class that allows you to chain multiple trees together and treat them as a single tree. It is specially useful when you want to merge trees within a macro. In the examples below we are merging two trees from two different files (both trees must have the same name):</p> <pre><code>TChain *chain = new TChain(\"treeName\");\nchain-&gt;Add(\"file1.root\");\nchain-&gt;Add(\"file2.root\");\n\n// Now you can loop over the chain as if it was a single tree and it will have the same methods and functions as a TTree\n</code></pre>"},{"location":"lecture3/#rdataframe","title":"RDataFrame","text":"<p>This topic has been discussed previously in Lecture 1, RDataFrame aims to be a more modern way to access root trees, similar to a pandas dataframe in python. It is a high-level interface to ROOT trees that allows you to perform operations on the data in a more intuitive way. It is a very powerful tool that can be used to filter, transform, and aggregate data in a very efficient way.</p> <p>To create an RDataFrame just extract the tree(s) you want in the dataframe:</p> <pre><code>// For a single file\nROOT::RDataFrame dataframeName1(\u201ctreename\u201d,\u201cfilename.root\u201d);\n// For multiple files\nstd::vector&lt;std::string&gt; files = {\u201cfilename1.root\u201d,\u201cfilename2.root\u201d};\nROOT::RDataFrame dataframeName2(\u201ctreename\u201d, files);\n</code></pre> <p>Once you have the trees you want inside a dataframe object, you can sift through events by passing them through a filter. The filter is a lambda function that returns a boolean value. If the function returns <code>true</code>, the event is kept, otherwise it is discarded. For example:</p> <pre><code>auto histName = dataframe.Filter(\"nJets &gt; 2\").Histo1D(\"lepton_pt\");\nhistName-&gt;Draw();\n</code></pre> <p>RDataFrames can be manipulated like databases. The \u2018Define\u2019 function will create new columns in the code, but you also can create them to compute values on the fly. Functions may also be fed into the <code>Filter</code> method to streamline and simplify the code. Be wary that the define function changes the dataframe by adding the column into the database. Here <code>r</code> will available for later use:</p> <pre><code>Double m = dataframe.Filter(\u201cx &gt; y\u201d).Define(\u201cr\u201d, \u201csqrt(x*x/2+y*y/4)\u201d ).Mean(\u201cr\u201d)\n</code></pre> <p>RDataFRame Actions and Queries</p> <p>Actions will aggregate data and output a smart pointer to a single value, while queries will simply return information about the RDataFrame object. Most RDataFrame actions are \u201clazy\u201d meaning that they only run the event-loop once. The trick is that actions are not executed at the moment they are called, but are delayed until the moment one of their results is accessed through the smart pointer. At that time, the event loop is triggered and all results are produced simultaneously.</p>"},{"location":"lecture3/#project","title":"Project","text":"<p>There are two projects that can be done. The goal here is open-ended and it is a chance for you to put in practice what you have learned and go as far as you want. The level of code expected from you will be of the level of the previous two exercises. </p>"},{"location":"lecture3/#project-1-weather-report","title":"Project 1: Weather Report","text":"<p>This project will use a real-life dataset of the weather conditions over the last year from two locations: here in Glasgow, and Valencia in Spain. As you might expect the weather patterns in both cities are very different so your task is to show and quantify what are these major differences. There are only two rules:</p> <ol> <li>This dataset is a <code>.csv</code> file which you will have to convert to ROOT format as a first step.</li> <li>All plotting and fitting must be done using ROOT functions.</li> </ol> <p>This datasets contains many different parameters and interesting comparisons that you can explore; some things you can do to get your started:</p> <ul> <li>Plotting the average temperature per day/week/month for each city and comparing them</li> <li>Fitting the change in temperature through the seasons</li> <li>Making histograms on the amount of precipitation</li> <li>Visualising and comparing sunrises and sunsets throughout the year for each city</li> </ul> <p>You can record your finding in a separate txt/doc file or comment your code along the way to let me know what you are doing.</p>"},{"location":"lecture3/#project-2-mystery-sample","title":"Project 2: Mystery Sample","text":"<p>This project takes inspiration from last's years project. The goal here is to explore a mystery dataset that has been generated by the ATLAS collaboration for a specific particle physics process. This project will require some particle physics knowledge. Explore the sample and try to uncover what process it is and which distributions best show the key characteristics of the process. Some paper reading could be beneficial here. There is one rule:</p> <ol> <li>All plotting and fitting must be done using ROOT functions.</li> </ol> <p>This dataset has a similar structure to the on in Lecture 1, with the addition of the <code>truth</code> tree. In particle physics, the <code>reco</code> tree shows the reconstructed particles after the detector simulation and all of it's effects. These effects come from the detector resolution, efficiency, and other factors and are essential when comparing to data.</p> <p>The <code>thruth</code> tree shows the \"true\" information from the particle coming directly from the MC generator and before detector simulation. It allows us to know exactly what process is being modelled and it is useful to make comparisons with the <code>reco</code> tree to understand detector effects.</p> Contents of the <code>truth</code> tree <p>There are many variables in the truth tree all preceded by the <code>Truth_MC</code> prefix. In this dataset, you will encounter 4 quarks, i.e. <code>q1</code>, <code>q2</code>, <code>q3</code>, and <code>q4</code> and 3 vector bosons, i.e. <code>V1</code>, <code>V2</code> and <code>V3</code>. The bosons will also decay to pairs of other particles, to conserve quantum numbers, which are represented by the variables that contain the words <code>decay1</code> or <code>decay2</code>. </p> <p>With this information, and by looking at the PDG codes/numbers (2nd page here), you should be able to identity each of the particles and then have an idea of which process they are part of. Note that the antiparticle PDG code/number of any particle is just the negative value of it.</p> <p>Here are some things you can do to get you started:</p> <ul> <li>Examine the <code>truth</code> tree, identify the particles and properties</li> <li>Compare alike variables in the <code>truth</code> and <code>reco</code> trees to understand the detector effects</li> <li>Make histograms form the <code>reco</code> tree to understand the kinematics of the detected particles</li> <li>Invariant masses of pairs of decaying particle can provide valuable information</li> <li>A pre-selection has been applied to the dataset, can you tell what it is?</li> </ul> <p>You can record your finding in a separate txt/doc file or comment your code along the way to let me know what you are doing.</p>"}]}